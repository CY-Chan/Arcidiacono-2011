{
    "contents" : "#################################################################################################\n# Arcidiacono and Miller (2011) coding assignment\n# Matt Beamer & Cheng-Yu Chan\n# 11/08/2014\n#################################################################################################\n\nsource('header.R')\n\n#################################################################################################\n# Global parameters. Will not be passing into functions.\n#################################################################################################\nN = 10^6\ntheta_1 = 10\ntheta_2 = 1\n\ns_1 = 1\ns_2 = 4\npi_s = .25\nbeta = .99\n\neta = 10^-5 #For calculating lower bound on x\nx_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))\n\nu <- values()\n\n#################################################################################################\n# Initialize CCPs\n# p is starting CCP estimate\n# phat is empty but initialized for the while loop\n#################################################################################################\np <- \n  matrix(rep(0.5, (x_m + 1) * 4), ncol = 4) %>%\n  rbind(c(0, 0, 1, 1)) %>%\n    as.data.frame\nphat <- \n  matrix(rep(0, (x_m + 2) * 4), ncol = 4) %>%\n  as.data.frame\n\n#################################################################################################\n# Apply the gamma operator to the CCP until phat converges to p.\n# Convergence is defined as the greatest difference between the iterations being arbitrarily small.\n#################################################################################################\nwhile(max(abs(phat - p)) > 10^(-16)){\n  phat <- p\n\n  # Apply the F operator to get the difference in value between keeping the engine and replacing it\n  vals <- Foperator(P = phat)\n\n  # Apply the lambda operator to get the updated CCPs\n  p <- lambda(v_bar = vals)\n}\n\n#################################################################################################\n# For N engines, with pi_s * N of them of type s_1 and (1 - pi_s) of them of type s_2, find the time until each engine is \n# new again (replaced in the last period). Store the results in a data frame with three columns:\n#   Column 1: engine number, from 1 to N\n#   Column 2: type, 1 for s_1 and 2 for s_2\n#   Column 3: mileage at replacement, x\n#################################################################################################\nengines <- data.frame(\n  engine_number = 1:N,\n  type = rbinom(N, 1, 1 - pi_s)\n) %>%\n  mutate(type = type + 1) %>%\n  arrange(type)                                 # Sort by brand for easy merging of mileage data later\n\nengine_count<- data.frame(table(engines[2]))    # Number of each brand from random draw.\n\nhistory<- \n  cbind(todeath(engine_count[1, 1], engine_count[1, 2]),\n        todeath(engine_count[2, 1], engine_count[2, 2]))\n\nengines<-\n  mutate(engines, replace_Period = apply(history, 2, which.min) - 1) %>%\n  arrange(engine_number)\n\nsaveRDS(engines,paste0(varSave,\"engines_data.rds\"))             # Save using saveRDS() for later use\n\n",
    "created" : 1415996674161.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1543300805",
    "id" : "B1EFA384",
    "lastKnownWriteTime" : 1415981390,
    "path" : "~/Projects/OPNS 523/Arcidiacono-2011/code/m.R",
    "project_path" : "code/m.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}