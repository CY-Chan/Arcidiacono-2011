source('header.R')
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
set.seed(1023)
epsilon <- rgev(n = N, xi = 0, mu = 0, beta = 1)
epsilon <- data.frame(rgev(n = N, xi = 0, mu = 0, beta = 1))
View(epsilon)
colnames(epsilon) <- "eps"
View(epsilon)
l_ply(dir(ex.mods), function(l) source(paste(ex.mods, l, sep="")))
source('header.R')
source('header.R')
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
source('header.R')
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
source('header.R')
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
?ddply
test<- ddply(epsilon, eps, lambda)
test<- ddply(epsilon, lambda)
View(epsilon)
test<- ddply(epsilon, "eps", lambda)
test<- ddply(epsilon, "eps", .fun = lambda)
test<- ddply(epsilon, "eps", .fun = "lambda")
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(rgev(n = N, xi = 0, mu = 0, beta = 1))
colnames(epsilon) <- "eps"
test<- ddply(epsilon, "eps", .fun = "lambda")
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(rgev(n = N, xi = 0, mu = 0, beta = 1))
colnames(epsilon) <- "eps"
#test<- ddply(epsilon, "eps", .fun = "lambda")
# Initialize CCPs
p <- matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
View(p)
epsilon <-
rgev(n = N, xi = 0, mu = 0, beta = 1) %>%
as.data.frame
View(epsilon)
epsilon <-
rgev(n = N, xi = 0, mu = 0, beta = 1) %>%
as.data.frame %>%
colnames() = "eps"
vals <- Foperator(P=p)
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=p)
s_1 = 1
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <-
rgev(n = N, xi = 0, mu = 0, beta = 1) %>%
as.data.frame
colnames(epsilon) = "eps"
#test<- ddply(epsilon, "eps", .fun = "lambda")
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=p)
u <- values()
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <-
rgev(n = N, xi = 0, mu = 0, beta = 1) %>%
as.data.frame
colnames(epsilon) = "eps"
#test<- ddply(epsilon, "eps", .fun = "lambda")
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=p)
warnings()
View(vals)
View(u)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <-
rgev(n = N, xi = 0, mu = 0, beta = 1) %>%
as.data.frame
colnames(epsilon) = "eps"
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=p)
# Apply the lambda operator to get the updated CCPs
phat <- lambda(v_bar = vals)
View(phat)
s=c(s_1,s_2)
x = 0:x_m
mdply(x,
function(t){
theta_1 * s - theta_2 * t
})
View(p)
View(phat)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=p)
# Apply the lambda operator to get the updated CCPs
phat <- lambda(v_bar = vals)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
phat <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
phat <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
View(p)
View(phat)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
while(phat != p){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
View(phat)
View(p)
while(phat != p){
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
while(phat != p){
print("here0")
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
while(1 != 2){
print("here0")
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
while(c(1:3) != c(2:4)){
print("here0")
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
warnings()
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
while(phat != p){
print("here0")
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
while(phat != p){
print("here0")
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
while(phat != p){
print("here0")
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
View(p)
View(phat)
1 / (1 + exp(v_bar))
vbar<- vals
1 / (1 + exp(v_bar))
v_bar<- vals
1 / (1 + exp(v_bar))
1 / (1 + exp(v_bar[,1]))
View(vals)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Need a better while loop test. Only using first element right now.
while(phat != p){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
View(phat)
View(p)
