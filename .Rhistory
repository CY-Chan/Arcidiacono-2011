p <- lambda(v_bar = vals)
print("here3")
}
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
while(phat != p){
print("here0")
phat <- p
print("here1")
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
print("here2")
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
print("here3")
}
View(p)
View(phat)
1 / (1 + exp(v_bar))
vbar<- vals
1 / (1 + exp(v_bar))
v_bar<- vals
1 / (1 + exp(v_bar))
1 / (1 + exp(v_bar[,1]))
View(vals)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Need a better while loop test. Only using first element right now.
while(phat != p){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
View(phat)
View(p)
source('header.R')
Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Need a better while loop test. Only using first element right now.
while(abs(max(phat - p)) > 10^(-16)){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Need a better while loop test. Only using first element right now.
while(abs(max(phat - p)) > 10^(-16)){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^2
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Need a better while loop test. Only using first element right now.
while(abs(max(phat - p)) > 10^(-16)){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^2
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 1) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2))
# Need a better while loop test. Only using first element right now.
while(abs(max(phat - p)) > 10^(-16)){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
todeath <- function(type){
laply(1:x_m,function(l) rbinom(1,1,p[l,type])) %>%
which.min
}
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s),
x0 <- rep(0,N)
)
View(engines)
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s),
x0 <- rep(0,N)
) %>%
mutate(type = type + 1)
View(engines)
todeath <- function(type){
laply(1:x_m,function(l) rbinom(1,1,p[l,type]))
}
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s),
x0 <- rep(0,N)
) %>%
mutate(type = type + 1)
engines2 <- apply(engines,1,function(y) todeath(y[2]))
View(engines)
View(engines2)
View(p)
View(vals)
x = 0:x_m
mdply(x,
function(t){
theta_1 * s - theta_2 * t
})
s=c(s_1,s_2)
mdply(x,
function(t){
theta_1 * s - theta_2 * t
})
View(u)
plot(p)
plot(p[,1])
plot(p[,2])
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
# Global parameters. Will not be passing into functions.
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
set.seed(1023)
epsilon <- data.frame(eps = rgev(n = N, xi = 0, mu = 0, beta = 1))
u <- values()
# Initialize CCPs
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
rbind(c(0,0,1,1)) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 2) * 4),ncol = 4) %>%
as.data.frame
# Or, if you want something more random
# p <- data.frame(p0s1 = runif(53),p0s2 = runif(53)) %>% mutate(p1s1 = 1-p0s1,p1s2 = 1-p0s2)
# Need a better while loop test. Only using first element right now.
while(max(abs(phat - p)) > 10^(-16)){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
View(p)
plot(p[1])
plot(p[,1])
plot(p[,2])
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s)
) %>%
mutate(type = type + 1)
View(engines)
sum(engines[2])
tab(engines[2])
table(engines[2])
?rbinom
engine_count<- table(engines[2])
engine_count<- data.frame(table(engines[2]))
View(engine_count)
temp<- todeath(1, 1000)
todeath <- function(type, type_Size){
laply(1:x_m,function(l) rbinom(1,type_Size,p[l,type])) %>%
which.min
}
temp<- todeath(1, 1000)
todeath(1, 1000)
todeath <- function(type, type_Size){
laply(1:x_m,function(l) rbinom(1,type_Size,p[l,type]))
}
todeath(1, 1000)
todeath <- function(type, type_Size){
laply(1:x_m,function(l) rbinom(type_Size,1,p[l,type]))
}
todeath(1, 1000)
temp<- todeath(1, 1000)
View(temp)
temp2<- temp %>% which.min
todeath <- function(type, type_Size){
laply(1:x_m,function(l) rbinom(type_Size,1,p[l,type])) %>%
which.min
}
temp<- todeath(1, 1000)
temp
N = 10^3
todeath <- function(type){
laply(1:x_m,function(l) rbinom(1,1,p[l,type])) %>%
which.min
}
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s)
) %>%
mutate(type = type + 1)
engines$x <- apply(engines,1,function(y) todeath(y[2]))
View(engines)
engines2 <- mutate(engines, x = x - 1)
View(engines2)
View(engines)
todeath <- function(type, type_Size){
laply(1:x_m,function(l) rbinom(type_Size,1,p[l,type]))
}
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s)
) %>%
mutate(type = type + 1)
engine_count<- data.frame(table(engines[2]))
history<- apply(engine_count, 1, function(y) todeath(y[1], y[2]))
View(engine_count)
?apply
todeath <- function(type, type_Size){
laply(1:x_m,function(l) rbinom(type_Size,1,p[l,type]))
}
history<- apply(engine_count, 1, function(y) todeath(y[1], y[2]))
todeath(engine_count[1,1],engine_count[1,2])
history<- apply(engine_count, 1, function(y) todeath(y[,1], y[,2]))
history<- apply(engine_count, 1, function(y) print(y))
engine_count<- array(table(engines[2]))
View(history)
engine_count<- array(t(table(engines[2])))
engine_coiunt
engine_count
?ddply
engine_count<- data.frame(table(engines[2]))
history<- ddply(engine_count, 1, function(y) print(y))
history<- ddply(engine_count, 1, function(y) todeath(y[,1], y[,2]))
View(history)
history<- ddply(engine_count, 1, function(y) cbind(todeath(y[,1], y[,2]))
)
View(history)
history<- cbind(todeath(engine_count[1,1], engine_count[1,2]),
todeath(engine_count[2,1], engine_count[2,2]))
View(history)
View(engines)
?sort
?order
?sort
?order
?arrange
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s)
) %>%
mutate(type = type + 1) %>%
arrange(type)
View(engines)
N = 10^6
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N,1,1 - pi_s)
) %>%
mutate(type = type + 1) %>%
arrange(type)
engine_count<- data.frame(table(engines[2]))
history<- cbind(todeath(engine_count[1,1], engine_count[1,2]),
todeath(engine_count[2,1], engine_count[2,2]))
View(history)
?which.min
x <- c(1:4, 0:5, 11)
which.min(x)
which.max(x)
x
presidents[1:30]
range(presidents, na.rm = TRUE)
which.min(presidents) # 28
which.max(presidents) #  2
history<-
cbind(todeath(engine_count[1,1], engine_count[1,2]),
todeath(engine_count[2,1], engine_count[2,2])) %>%
data.frame
View(history)
which.min(history)
test<- ddply(history,which.min)
?ddply
ddply(baseball[1:100,], ~ year, nrow)
baseball[1:5,]
test<- apply(history,2,which.min)
test<- data.frame(test)
View(test)
history<-
cbind(todeath(engine_count[1,1], engine_count[1,2]),
todeath(engine_count[2,1], engine_count[2,2]))
test<- apply(history,2,which.min)
View(history)
dim(test)
?dimension
??dimension
test[1:10]
?append
?mutate
mutate(engines, replace_Period = apply(history,2,which.min))
View(engines)
engines<- mutate(engines, replace_Period = apply(history,2,which.min))
View(engines)
engines<- mutate(engines, replace_Period = apply(history,2,which.min) - 1)
View(engines)
View(engines)
View(engines)
engines<-
mutate(engines, replace_Period = apply(history,2,which.min) - 1) %>%
arrange(engine_number)
#################################################################################################
# Arcidiacono and Miller (2011) coding assignment
# Matt Beamer & Cheng-Yu Chan
# 11/08/2014
#################################################################################################
source('header.R')
#################################################################################################
# Global parameters. Will not be passing into functions.
#################################################################################################
N = 10^6
theta_1 = 10
theta_2 = 1
s_1 = 1
s_2 = 4
pi_s = .25
beta = .99
eta = 10^-5 #For calculating lower bound on x
x_m = max(x_bound(eta = eta, s = s_1), x_bound(eta = eta, s = s_2))
u <- values()
#################################################################################################
# Initialize CCPs
# p is starting CCP estimate
# phat is empty but initialized for the while loop
#################################################################################################
p <-
matrix(rep(0.5,(x_m + 1) * 4),ncol = 4) %>%
rbind(c(0,0,1,1)) %>%
as.data.frame
phat <-
matrix(rep(0,(x_m + 2) * 4),ncol = 4) %>%
as.data.frame
#################################################################################################
# Apply the gamma operator to the CCP until phat converges to p.
# Convergence is defined as the greatest difference between the iterations being arbitrarily small.
#################################################################################################
while(max(abs(phat - p)) > 10^(-16)){
phat <- p
# Apply the F operator to get the difference in value between keeping the engine and replacing it
vals <- Foperator(P=phat)
# Apply the lambda operator to get the updated CCPs
p <- lambda(v_bar = vals)
}
#################################################################################################
# For N engines, with pi_s * N of them of type s_1 and (1 - pi_s) of them of type s_2, find the time until each engine is
# new again (replaced in the last period). Store the results in a data frame with three columns:
#   Column 1: engine number, from 1 to N
#   Column 2: type, 1 for s_1 and 2 for s_2
#   Column 3: mileage at replacement, x
#################################################################################################
engines <- data.frame(
engine_number = 1:N,
type = rbinom(N, 1, 1 - pi_s)
) %>%
mutate(type = type + 1) %>%
arrange(type)                                 # Sort by brand for easy merging of mileage data later
engine_count<- data.frame(table(engines[2]))    # Number of each brand from random draw.
history<-
cbind(todeath(engine_count[1,1], engine_count[1,2]),
todeath(engine_count[2,1], engine_count[2,2]))
engines<-
mutate(engines, replace_Period = apply(history,2,which.min) - 1) %>%
arrange(engine_number)
saveRDS(engines,"engines_data.rds")             # Save using saveRDS() for later use
